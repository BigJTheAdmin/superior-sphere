---
// File: src/pages/tags/[tag]/[...page].astro
import PageLayout from "@/layouts/Base.astro";
import { getCollection, type CollectionEntry } from "astro:content";
import type { GetStaticPaths, Page } from "astro";

type Post = CollectionEntry<"post">; // change if your collection id differs (e.g. "blog")

function norm(v: unknown): string {
  return String(v == null ? "" : v).trim();
}

function hasTag(entry: Post, tag: string): boolean {
  const fm: any = entry.data;
  if (!Array.isArray(fm?.tags)) return false;
  return fm.tags.map(norm).includes(tag);
}

function sortByDate(a: Post, b: Post): number {
  const ad: any = (a.data as any)?.date ?? 0;
  const bd: any = (b.data as any)?.date ?? 0;
  return new Date(bd).getTime() - new Date(ad).getTime();
}

export const getStaticPaths = (async ({ paginate }) => {
  const PER_PAGE = 10;

  // Load and prep all posts
  const posts = await getCollection("post"); // <-- change if your collection id differs
  const allTags = new Set<string>();

  for (const p of posts) {
    const fm: any = p.data;
    if (Array.isArray(fm?.tags)) {
      for (const t of fm.tags) {
        const tt = norm(t);
        if (tt) allTags.add(tt);
      }
    }
  }

  // Build paginated pages for each tag
  const paths = [];
  for (const tag of Array.from(allTags)) {
    const filtered = posts.filter((p) => hasTag(p, tag)).sort(sortByDate);
    const items = paginate(filtered, {
      pageSize: PER_PAGE,
      params: { tag, page: [] }, // static-safe catch-all
    });
    paths.push(...items);
  }

  return paths;
}) satisfies GetStaticPaths;

interface Props {
  params: { tag: string };
  page: Page<Post>;
}

const { params, page } = Astro.props;
const tag = params.tag;

function hrefFor(entry: Post): string {
  const fm: any = entry.data;
  if (fm?.permalink) return fm.permalink;
  // Avoid template literals to prevent accidental regex parsing
  return "/posts/" + entry.slug + "/";
}

const prevHref: string | null = page.url.prev ?? null;
const nextHref: string | null = page.url.next ?? null;
---

<PageLayout meta={{ title: "#" + tag, description: "Posts tagged " + tag }}>
  <section class="container mx-auto px-6 py-10">
    <header class="mb-8">
      <h1 class="text-3xl font-semibold tracking-tight">#{tag}</h1>
      <p class="text-neutral-400 mt-1">Posts tagged with “{tag}”.</p>
    </header>

    <ul class="grid gap-6">
      {page.data.map((entry) => {
        const fm: any = entry.data;
        const title: string = fm?.title ?? entry.slug;
        const summary: string = fm?.description ?? fm?.excerpt ?? "";
        const dateStr: string = fm?.date ? new Date(fm.date).toLocaleDateString() : "";

        return (
          <li class="rounded-xl border border-neutral-800/80 bg-neutral-900/40 p-5 hover:border-neutral-700 transition-colors">
            <a href={hrefFor(entry)} class="block focus:outline-none focus:ring-2 focus:ring-green-500 rounded-lg">
              <h2 class="text-xl font-medium">{title}</h2>
              {dateStr && <p class="text-xs text-neutral-400 mt-1">{dateStr}</p>}
              {summary && <p class="text-neutral-300 mt-2">{summary}</p>}
            </a>
          </li>
        );
      })}
    </ul>

    <nav class="mt-10 flex items-center justify-between">
      {prevHref ? (
        <a class="rounded-md border border-neutral-700 px-4 py-2 text-sm hover:bg-neutral-800" href={prevHref}>← Newer</a>
      ) : (
        <span class="rounded-md border border-neutral-900 px-4 py-2 text-sm text-neutral-600">← Newer</span>
      )}

      <p class="text-neutral-500 text-sm">
        Page {page.currentPage} of {page.lastPage}
      </p>

      {nextHref ? (
        <a class="rounded-md border border-neutral-700 px-4 py-2 text-sm hover:bg-neutral-800" href={nextHref}>Older →</a>
      ) : (
        <span class="rounded-md border border-neutral-900 px-4 py-2 text-sm text-neutral-600">Older →</span>
      )}
    </nav>
  </section>
</PageLayout>
