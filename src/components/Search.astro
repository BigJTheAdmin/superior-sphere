---
// Search modal — same shell/UX as your old one, but powered by /api/pages-search.json
// Keeps: button trigger, <dialog>, Ctrl/⌘+K shortcut, click-outside to close.
import "@/styles/blocks/search.css";
---
<site-search class="ms-auto" id="search">
  <button
    class="hover:text-accent flex h-9 w-9 cursor-pointer items-center justify-center rounded-md"
    aria-keyshortcuts="Control+K Meta+K"
    data-open-modal
    disabled
  >
    <!-- Magnifying glass -->
    <svg aria-hidden="true" class="h-7 w-7" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M0 0h24v24H0z" stroke="none"></path>
      <circle cx="11" cy="11" r="7"></circle>
      <path d="M21 21l-6-6"></path>
    </svg>
    <span class="sr-only">Open Search</span>
  </button>

  <dialog
    aria-label="search"
    class="bg-global-bg h-full max-h-full w-full max-w-full border border-zinc-400 shadow-sm backdrop:backdrop-blur-sm open:flex sm:mx-auto sm:mt-16 sm:mb-auto sm:h-max sm:max-h-[calc(100%-8rem)] sm:min-h-[15rem] sm:w-5/6 sm:max-w-[48rem] sm:rounded-md"
  >
    <div class="dialog-frame flex grow flex-col gap-4 p-6 pt-12 sm:pt-6">
      <button class="ms-auto cursor-pointer rounded-md bg-zinc-200 p-2 font-semibold dark:bg-zinc-700" data-close-modal>Close</button>

      <!-- SEARCH INPUT + RESULTS (replaces pagefind UI) -->
      <div class="flex flex-col gap-3">
        <div class="relative">
          <span class="pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 opacity-70">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="11" cy="11" r="7"></circle>
              <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
            </svg>
          </span>
          <input
            id="pts-search-input"
            type="search"
            placeholder="Search pages…"
            class="w-full rounded-md border border-zinc-400 bg-transparent py-2 pl-9 pr-9 outline-none focus:border-accent"
            autocomplete="off"
            aria-controls="pts-search-results"
          />
          <button id="pts-search-clear" class="absolute right-2 top-1/2 -translate-y-1/2 rounded p-1 opacity-70 hover:opacity-100" title="Clear" aria-label="Clear" hidden>
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>

        <div id="pts-search-results" role="listbox" class="max-h-[50vh] overflow-auto rounded-md border border-zinc-400">
          <!-- results render here -->
        </div>
      </div>
    </div>
  </dialog>
</site-search>

<script>
  type PageDoc = {
    title: string;
    url: string;
    description?: string;
    keywords?: string[];
  };

  class SiteSearch extends HTMLElement {
    #closeBtn: HTMLButtonElement | null;
    #dialog: HTMLDialogElement | null;
    #dialogFrame: HTMLDivElement | null;
    #openBtn: HTMLButtonElement | null;
    #controller: AbortController;

    // local state
    #index: PageDoc[] = [];
    #loaded = false;

    constructor() {
      super();
      this.#openBtn = this.querySelector<HTMLButtonElement>("button[data-open-modal]");
      this.#closeBtn = this.querySelector<HTMLButtonElement>("button[data-close-modal]");
      this.#dialog = this.querySelector<HTMLDialogElement>("dialog");
      this.#dialogFrame = this.querySelector<HTMLDivElement>(".dialog-frame");
      this.#controller = new AbortController();

      // Button wiring
      if (this.#openBtn) {
        this.#openBtn.addEventListener("click", this.openModal);
        this.#openBtn.disabled = false;
      } else {
        console.warn("Search button not found");
      }

      if (this.#closeBtn) {
        this.#closeBtn.addEventListener("click", this.closeModal);
      } else {
        console.warn("Close button not found");
      }

      if (this.#dialog) {
        this.#dialog.addEventListener("close", () => {
          window.removeEventListener("click", this.onWindowClick);
        });
      } else {
        console.warn("Dialog not found");
      }
    }

    connectedCallback() {
      window.addEventListener("keydown", this.onWindowKeydown, { signal: this.#controller.signal });
      // preload index on idle
      const onIdle = (window as any).requestIdleCallback || ((cb: any) => setTimeout(cb, 1));
      onIdle(() => this.#loadIndex());
    }

    disconnectedCallback() {
      this.#controller.abort();
    }

    openModal = (event?: MouseEvent) => {
      if (!this.#dialog) return;
      this.#dialog.showModal();
      // focus input when opened
      const input = this.querySelector<HTMLInputElement>("#pts-search-input");
      input?.focus();
      event?.stopPropagation();
      window.addEventListener("click", this.onWindowClick, { signal: this.#controller.signal });
      // ensure baseline list shows
      this.#renderResults(this.#index.slice(0, 10));
    };

    closeModal = () => this.#dialog?.close();

    onWindowClick = (event: MouseEvent) => {
      const isLink = "href" in (event.target || {});
      if (isLink || (document.body.contains(event.target as Node) && !this.#dialogFrame?.contains(event.target as Node))) {
        this.closeModal();
      }
    };

    onWindowKeydown = (e: KeyboardEvent) => {
      if (!this.#dialog) return;
      if ((e.metaKey === true || e.ctrlKey === true) && e.key === "k") {
        this.#dialog.open ? this.closeModal() : this.openModal();
        e.preventDefault();
      }
    };

    async #loadIndex() {
      if (this.#loaded) return;
      try {
        const res = await fetch("/api/pages-search.json", { cache: "force-cache" });
        if (!res.ok) throw new Error("Failed to fetch page index");
        this.#index = (await res.json()) as PageDoc[];
      } catch (err) {
        console.error(err);
        this.#index = [];
      } finally {
        this.#loaded = true;
        // wire input handlers after index is ready
        this.#wireSearchHandlers();
      }
    }

    #wireSearchHandlers() {
      const input = this.querySelector<HTMLInputElement>("#pts-search-input");
      const clearBtn = this.querySelector<HTMLButtonElement>("#pts-search-clear");
      if (!input) return;

      const doSearch = () => {
        const q = input.value.trim().toLowerCase();
        if (!q) {
          this.#renderResults(this.#index.slice(0, 10));
          clearBtn && (clearBtn.hidden = true);
          return;
        }
        clearBtn && (clearBtn.hidden = false);
        const terms = q.split(/\s+/).filter(Boolean);
        const score = (doc: PageDoc) => {
          let s = 0;
          const t = (doc.title || "").toLowerCase();
          const d = (doc.description || "").toLowerCase();
          const k = (doc.keywords || []).map(x => (x || "").toLowerCase());
          for (const term of terms) {
            if (t.includes(term)) s += 3;
            if (k.some(x => x.includes(term))) s += 2;
            if (d.includes(term)) s += 1;
          }
          return s;
        };
        const results = this.#index
          .map(doc => ({ doc, s: score(doc) }))
          .filter(x => x.s > 0)
          .sort((a, b) => b.s - a.s)
          .slice(0, 50)
          .map(x => x.doc);
        this.#renderResults(results);
      };

      input.addEventListener("input", doSearch, { signal: this.#controller.signal });
      input.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          input.value = "";
          clearBtn && (clearBtn.hidden = true);
          this.#renderResults(this.#index.slice(0, 10));
        }
      }, { signal: this.#controller.signal });

      clearBtn?.addEventListener("click", () => {
        input.value = "";
        clearBtn.hidden = true;
        this.#renderResults(this.#index.slice(0, 10));
        input.focus();
      }, { signal: this.#controller.signal });
    }

    #renderResults(items: PageDoc[]) {
      const box = this.querySelector<HTMLDivElement>("#pts-search-results");
      if (!box) return;
      if (!items.length) {
        box.innerHTML = `<div class="p-3 text-sm opacity-70">No matches. Try different keywords.</div>`;
        return;
      }
      box.innerHTML = items.map(it => `
        <a href="${it.url}" role="option" class="block border-b border-zinc-700/40 p-3 hover:bg-accent/10 focus:bg-accent/10 focus:outline-none">
          <div class="font-semibold">${it.title}</div>
          ${it.description ? `<div class="mt-0.5 text-sm opacity-80">${it.description}</div>` : ""}
        </a>
      `).join("");
    }
  }

  customElements.define("site-search", SiteSearch);
</script>
